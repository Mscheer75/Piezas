        -:    0:Source:Piezas.cpp
        -:    0:Programs:2
        -:    1:#include "Piezas.h"
        -:    2:#include <vector>
        -:    3:#include <stdio.h>
        -:    4:/** CLASS Piezas
        -:    5: * Class for representing a Piezas vertical board, which is roughly based
        -:    6: * on the game "Connect Four" where pieces are placed in a column and 
        -:    7: * fall to the bottom of the column, or on top of other pieces already in
        -:    8: * that column. For an illustration of the board, see:
        -:    9: *  https://en.wikipedia.org/wiki/Connect_Four
        -:   10: *
        -:   11: * Board coordinates [row,col] should match with:
        -:   12: * [2,0][2,1][2,2][2,3]
        -:   13: * [1,0][1,1][1,2][1,3]
        -:   14: * [0,0][0,1][0,2][0,3]
        -:   15: * So that a piece dropped in column 2 should take [0,2] and the next one
        -:   16: * dropped in column 2 should take [1,2].
        -:   17:**/
        -:   18:
        -:   19:
        -:   20:/**
        -:   21: * Constructor sets an empty board (default 3 rows, 4 columns) and 
        -:   22: * specifies it is X's turn first
        -:   23:**/
function _ZN6PiezasC2Ev called 24 returned 100% blocks executed 64%
       24:   24:Piezas::Piezas()
call    0 returned 24
call    1 never executed
        -:   25:{
       24:   26:	board.resize(BOARD_ROWS, std::vector <Piece> (BOARD_COLS));
call    0 returned 24
call    1 returned 24
branch  2 taken 24 (fallthrough)
branch  3 taken 0 (throw)
call    4 returned 24
branch  5 taken 24 (fallthrough)
branch  6 taken 0 (throw)
call    7 returned 24
call    8 returned 24
call    9 never executed
call   10 never executed
       24:   27:	reset();
call    0 returned 24
        -:   28:
        -:   29:
       24:   30:}
        -:   31:
        -:   32:/**
        -:   33: * Resets each board location to the Blank Piece value, with a board of the
        -:   34: * same size as previously specified
        -:   35:**/
function _ZN6Piezas5resetEv called 26 returned 100% blocks executed 100%
       26:   36:void Piezas::reset()
        -:   37:{
       26:   38:	turn = X;
      104:   39:	for(int i=0; i<BOARD_ROWS; i++)
branch  0 taken 78 (fallthrough)
branch  1 taken 26
      390:   40:		for(int j=0; j<BOARD_COLS; j++)
branch  0 taken 312 (fallthrough)
branch  1 taken 78
      312:   41:			board[i][j] = Blank;
call    0 returned 312
call    1 returned 312
        -:   42:
        -:   43:
       26:   44:}
        -:   45:
        -:   46:/**
        -:   47: * Places a piece of the current turn on the board, returns what
        -:   48: * piece is placed, and toggles which Piece's turn it is. dropPiece does 
        -:   49: * NOT allow to place a piece in a location where a column is full.
        -:   50: * In that case, placePiece returns Piece Blank value 
        -:   51: * Out of bounds coordinates return the Piece Invalid value
        -:   52: * Trying to drop a piece where it cannot be placed loses the player's turn
        -:   53:**/ 
function _ZN6Piezas9dropPieceEi called 157 returned 100% blocks executed 100%
      157:   54:Piece Piezas::dropPiece(int column)
        -:   55:{
      157:   56:	bool placed = false;
      157:   57:	bool inBounds = false;
      157:   58:	Piece placedPiece = Blank;
      157:   59:	if( column <= BOARD_COLS && column > -1)
branch  0 taken 155 (fallthrough)
branch  1 taken 2
branch  2 taken 154 (fallthrough)
branch  3 taken 1
        -:   60:	{
      154:   61:		inBounds = true;
      327:   62:		for( int i = 0; i < BOARD_ROWS; i++)
branch  0 taken 316 (fallthrough)
branch  1 taken 11
        -:   63:		{
      316:   64:			if(board[i][column] == Blank && placed == false)
call    0 returned 316
call    1 returned 316
branch  2 taken 143 (fallthrough)
branch  3 taken 173
branch  4 taken 143 (fallthrough)
branch  5 taken 0
branch  6 taken 143 (fallthrough)
branch  7 taken 173
        -:   65:			{
      143:   66:				board[i][column] = turn;
call    0 returned 143
call    1 returned 143
      143:   67:				placed = true;
      143:   68:				placedPiece = turn;
      143:   69:				break;
        -:   70:			}
        -:   71:		
        -:   72:		}
        -:   73:	}
        -:   74:
      157:   75:	if (turn == X)
branch  0 taken 81 (fallthrough)
branch  1 taken 76
        -:   76:	{
       81:   77:		turn = O;
       76:   78:	}else if(turn == O)
branch  0 taken 76 (fallthrough)
branch  1 taken 0
        -:   79:	{
       76:   80:		turn = X;
        -:   81:	}
        -:   82:
      157:   83:	if(!inBounds)
branch  0 taken 3 (fallthrough)
branch  1 taken 154
        3:   84:		placedPiece = Invalid;
        -:   85:
      157:   86:    return placedPiece;
        -:   87:}
        -:   88:
        -:   89:/**
        -:   90: * Returns what piece is at the provided coordinates, or Blank if there
        -:   91: * are no pieces there, or Invalid if the coordinates are out of bounds
        -:   92:**/
function _ZN6Piezas7pieceAtEii called 7 returned 100% blocks executed 100%
        7:   93:Piece Piezas::pieceAt(int row, int column)
        -:   94:{
        7:   95:	if(BOARD_ROWS > row && row >=0 && BOARD_COLS > column && column >= 0)
branch  0 taken 5 (fallthrough)
branch  1 taken 2
branch  2 taken 5 (fallthrough)
branch  3 taken 0
branch  4 taken 5 (fallthrough)
branch  5 taken 0
branch  6 taken 5 (fallthrough)
branch  7 taken 0
        -:   96:	{
        5:   97:		return board[row][column];
call    0 returned 5
call    1 returned 5
        -:   98:	}
        -:   99:
        2:  100:    return Invalid;
        -:  101:}
        -:  102:
        -:  103:/**
        -:  104: * Returns which Piece has won, if there is a winner, Invalid if the game
        -:  105: * is not over, or Blank if the board is filled and no one has won ("tie").
        -:  106: * For a game to be over, all locations on the board must be filled with X's 
        -:  107: * and O's (i.e. no remaining Blank spaces). The winner is which player has
        -:  108: * the most adjacent pieces in a single line. Lines can go either vertically
        -:  109: * or horizontally. If both X's and O's have the same max number of pieces in a
        -:  110: * line, it is a tie.
        -:  111:**/
function _ZN6Piezas9gameStateEv called 9 returned 100% blocks executed 97%
        9:  112:Piece Piezas::gameState()
        -:  113:{
        9:  114:	int maxX = 0;
        9:  115:	int maxO = 0;
        -:  116:
        9:  117:	int xCount = 1;
        9:  118:	int oCount = 1;
       32:  119:	for(int i = 0; i < BOARD_ROWS; i++)
branch  0 taken 25 (fallthrough)
branch  1 taken 7
        -:  120:	{
      118:  121:		for(int j =0; j < BOARD_COLS; j++)
branch  0 taken 95 (fallthrough)
branch  1 taken 23
        -:  122:		{
       95:  123:			if(board[i][j] == Blank || board[i][j] == Invalid)
call    0 returned 95
call    1 returned 95
branch  2 taken 93 (fallthrough)
branch  3 taken 2
call    4 returned 93
call    5 returned 93
branch  6 taken 0 (fallthrough)
branch  7 taken 93
branch  8 taken 2 (fallthrough)
branch  9 taken 93
        2:  124:				return Invalid;
        -:  125:		}
        -:  126:	}
        -:  127:	
       28:  128:	for(int i = 0; i < BOARD_ROWS; i++)
branch  0 taken 21 (fallthrough)
branch  1 taken 7
        -:  129:	{
       21:  130:		xCount = 1;
       21:  131:		oCount = 1;
      105:  132:		for(int j =0; j< BOARD_COLS; j++)
branch  0 taken 84 (fallthrough)
branch  1 taken 21
        -:  133:		{
        -:  134:		        	
       84:  135:			if( j-1 >=0 && board[i][j] == board[i][j-1])
branch  0 taken 63 (fallthrough)
branch  1 taken 21
call    2 returned 63
call    3 returned 63
call    4 returned 63
call    5 returned 63
branch  6 taken 22 (fallthrough)
branch  7 taken 41
branch  8 taken 22 (fallthrough)
branch  9 taken 62
        -:  136:			{
       22:  137:				if(board[i][j] == X)
call    0 returned 22
call    1 returned 22
branch  2 taken 9 (fallthrough)
branch  3 taken 13
        -:  138:				{
        9:  139:					xCount++;
        -:  140:				}else
        -:  141:				{
       13:  142:					oCount++;
        -:  143:				}
        -:  144:			}
       62:  145:			else if(j-1 >=0) 
branch  0 taken 41 (fallthrough)
branch  1 taken 21
        -:  146:			{
       41:  147:				if(board[i][j-1] == X)
call    0 returned 41
call    1 returned 41
branch  2 taken 25 (fallthrough)
branch  3 taken 16
        -:  148:				{
       25:  149:					if(xCount > maxX)
branch  0 taken 9 (fallthrough)
branch  1 taken 16
        9:  150:						maxX = xCount;
       25:  151:					xCount = 1;
        -:  152:				}
       16:  153:				else if(board[i][j-1] == O)
call    0 returned 16
call    1 returned 16
branch  2 taken 16 (fallthrough)
branch  3 taken 0
        -:  154:				{
       16:  155:					if(oCount > maxO)
branch  0 taken 8 (fallthrough)
branch  1 taken 8
        8:  156:						maxO = oCount;
        -:  157:
       16:  158:					oCount = 1;
        -:  159:				}
        -:  160:			}
        -:  161:			
        -:  162:		}
        -:  163:	}
        -:  164:	
        -:  165:
       35:  166:	for(int i = 0; i < BOARD_COLS; i++)
branch  0 taken 28 (fallthrough)
branch  1 taken 7
        -:  167:	{
       28:  168:		xCount = 1;
       28:  169:		oCount = 1;
        -:  170:
      112:  171:		for(int j =0; j < BOARD_ROWS; j++)
branch  0 taken 84 (fallthrough)
branch  1 taken 28
        -:  172:		{
        -:  173:			
       84:  174:			if(j-1 >=0 && board[j][i] == board[j-1][i]) 
branch  0 taken 56 (fallthrough)
branch  1 taken 28
call    2 returned 56
call    3 returned 56
call    4 returned 56
call    5 returned 56
branch  6 taken 21 (fallthrough)
branch  7 taken 35
branch  8 taken 21 (fallthrough)
branch  9 taken 63
        -:  175:			{
       21:  176:				if(board[j][i] == X )
call    0 returned 21
call    1 returned 21
branch  2 taken 10 (fallthrough)
branch  3 taken 11
        -:  177:				{
       10:  178:					xCount++;
        -:  179:				}else
        -:  180:				{
       11:  181:					oCount++;
        -:  182:				}
        -:  183:			}
       63:  184:			else if(BOARD_ROWS > j && j-1 >=0) 
branch  0 taken 63 (fallthrough)
branch  1 taken 0
branch  2 taken 35 (fallthrough)
branch  3 taken 28
        -:  185:			{
       35:  186:				if(board[j-1][i] == X)
call    0 returned 35
call    1 returned 35
branch  2 taken 18 (fallthrough)
branch  3 taken 17
        -:  187:				{
       18:  188:					if(xCount > maxX)
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:  189:						maxX = xCount;
       18:  190:					xCount = 1;
        -:  191:				}
       17:  192:				else if(board[j-1][i] == O)
call    0 returned 17
call    1 returned 17
branch  2 taken 17 (fallthrough)
branch  3 taken 0
        -:  193:				{
       17:  194:					if(oCount > maxO)
branch  0 taken 1 (fallthrough)
branch  1 taken 16
        1:  195:						maxO = oCount;
        -:  196:
       17:  197:					oCount = 1;
        -:  198:				}
        -:  199:			}	
        -:  200:		}
        -:  201:	}
        7:  202:	printf("maxX %i \n", maxX);
call    0 returned 7
        7:  203:	printf("maxO %i \n", maxO);	
call    0 returned 7
        7:  204:	if( maxX > maxO)
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####:  205:    		return X;
        7:  206:	else if(maxO > maxX)
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####:  207:		return O;
        -:  208:	else 
        7:  209:		return Blank;
        -:  210:}
        -:  211:
